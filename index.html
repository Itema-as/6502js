<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<title>MOS 6502 Simulator</title>
	<link rel="stylesheet" href="style.css">
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
		integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
</head>
<body>
	<div class="container-fluid">
		<div class="row">
			<div id="simulator">
				<h1>MOS 6502 Simulator</h1>
				<nav class="navbar" style="width: 620px;">
					<div class="toc">
						<ul class="nav">
							<li class="nav-item"><a class="nav-link" href="#INTRO">Introduction</a></li>
							<li class="nav-item"><a class="nav-link" href="#NOTES">Notes</a></li>
							<li class="nav-item"><a class="nav-link" href="#PC">Program Counter</a></li>
							<li class="nav-item"><a class="nav-link" href="#WRAP">Wrap-Around</a></li>
						</ul>
					</div>
					<div class="toc">
						<ul class="nav">
							<li class="nav-item"><a class="nav-link" href="#ADC">ADC</a></li>
							<li class="nav-item"><a class="nav-link" href="#AND">AND</a></li>
							<li class="nav-item"><a class="nav-link" href="#ASL">ASL</a></li>
							<li class="nav-item"><a class="nav-link" href="#BCC">BCC</a></li>
							<li class="nav-item"><a class="nav-link" href="#BCS">BCS</a></li>
							<li class="nav-item"><a class="nav-link" href="#BEQ">BEQ</a></li>
							<li class="nav-item"><a class="nav-link" href="#BMI">BMI</a></li>
							<li class="nav-item"><a class="nav-link" href="#BNE">BNE</a></li>
							<li class="nav-item"><a class="nav-link" href="#BPL">BPL</a></li>
							<li class="nav-item"><a class="nav-link" href="#BVC">BVC</a></li>
							<li class="nav-item"><a class="nav-link" href="#BVS">BVS</a></li>
							<li class="nav-item"><a class="nav-link" href="#BIT">BIT</a></li>
							<li class="nav-item"><a class="nav-link" href="#BRK">BRK</a></li>
							<li class="nav-item"><a class="nav-link" href="#CLC">CLC</a></li>
						</ul>
						<ul class="nav">
							<li class="nav-item"><a class="nav-link" href="#CLD">CLD</a></li>
							<li class="nav-item"><a class="nav-link" href="#CLI">CLI</a></li>
							<li class="nav-item"><a class="nav-link" href="#CLV">CLV</a></li>
							<li class="nav-item"><a class="nav-link" href="#CMP">CMP</a></li>
							<li class="nav-item"><a class="nav-link" href="#CPX">CPX</a></li>
							<li class="nav-item"><a class="nav-link" href="#CPY">CPY</a></li>
							<li class="nav-item"><a class="nav-link" href="#DEC">DEC</a></li>
							<li class="nav-item"><a class="nav-link" href="#DEX">DEX</a></li>
							<li class="nav-item"><a class="nav-link" href="#DEY">DEY</a></li>
							<li class="nav-item"><a class="nav-link" href="#EOR">EOR</a></li>
							<li class="nav-item"><a class="nav-link" href="#INC">INC</a></li>
							<li class="nav-item"><a class="nav-link" href="#INX">INX</a></li>
							<li class="nav-item"><a class="nav-link" href="#INY">INY</a></li>
							<li class="nav-item"><a class="nav-link" href="#JMP">JMP</a></li>
						</ul>
						<ul class="nav">
							<li class="nav-item"><a class="nav-link" href="#JSR">JSR</a></li>
							<li class="nav-item"><a class="nav-link" href="#LDA">LDA</a></li>
							<li class="nav-item"><a class="nav-link" href="#LDX">LDX</a></li>
							<li class="nav-item"><a class="nav-link" href="#LDY">LDY</a></li>
							<li class="nav-item"><a class="nav-link" href="#LSR">LSR</a></li>
							<li class="nav-item"><a class="nav-link" href="#NOP">NOP</a></li>
							<li class="nav-item"><a class="nav-link" href="#ORA">ORA</a></li>
							<li class="nav-item"><a class="nav-link" href="#PHA">PHA</a></li>
							<li class="nav-item"><a class="nav-link" href="#PHP">PHP</a></li>
							<li class="nav-item"><a class="nav-link" href="#PLA">PLA</a></li>
							<li class="nav-item"><a class="nav-link" href="#PLP">PLP</a></li>
							<li class="nav-item"><a class="nav-link" href="#ROL">ROL</a></li>
							<li class="nav-item"><a class="nav-link" href="#ROR">ROR</a></li>
							<li class="nav-item"><a class="nav-link" href="#RTI">RTI</a></li>
						</ul>
						<ul class="nav">
							<li class="nav-item"><a class="nav-link" href="#RTS">RTS</a></li>
							<li class="nav-item"><a class="nav-link" href="#SBC">SBC</a></li>
							<li class="nav-item"><a class="nav-link" href="#SEC">SEC</a></li>
							<li class="nav-item"><a class="nav-link" href="#SED">SED</a></li>
							<li class="nav-item"><a class="nav-link" href="#SEI">SEI</a></li>
							<li class="nav-item"><a class="nav-link" href="#STA">STA</a></li>
							<li class="nav-item"><a class="nav-link" href="#STX">STX</a></li>
							<li class="nav-item"><a class="nav-link" href="#STY">STY</a></li>
							<li class="nav-item"><a class="nav-link" href="#TAX">TAX</a></li>
							<li class="nav-item"><a class="nav-link" href="#TAY">TAY</a></li>
							<li class="nav-item"><a class="nav-link" href="#TSX">TSX</a></li>
							<li class="nav-item"><a class="nav-link" href="#TXA">TXA</a></li>
							<li class="nav-item"><a class="nav-link" href="#TXS">TXS</a></li>
							<li class="nav-item"><a class="nav-link" href="#TYA">TYA</a></li>
						</ul>
					</div>
				</nav> <!-- table-of-contents -->
				<div class="widget" >
					<div id="toolbar" class="btn-group btn-group-sm btn-block" role="group">
						<input type="button" value="Assemble" class="btn btn-primary assembleButton" />
						<input type="button" value="Run" class="btn btn-success runButton" />
						<input type="button" value="Reset" class="btn btn-danger resetButton" />
						<input type="button" value="Hexdump" class="btn btn-secondary hexdumpButton" />
						<input type="button" value="Disassemble" class="btn btn-secondary disassembleButton" />
						<button id="load" type="button" class="btn btn-secondary dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Load</button>
						<div class="dropdown-menu" aria-labelledby="load">
							<a class="dropdown-item loadButton" href="#">alive.asm</a>
							<a class="dropdown-item loadButton" href="#">calculator.asm</a>
							<a class="dropdown-item loadButton" href="#">compo-May07-1st.asm</a>
							<a class="dropdown-item loadButton" href="#">compo-May07-2nd.asm</a>
							<a class="dropdown-item loadButton" href="#">compo-May07-3rd.asm</a>
							<a class="dropdown-item loadButton" href="#">byterun.asm</a>
							<a class="dropdown-item loadButton" href="#">colors.asm</a>
							<a class="dropdown-item loadButton" href="#">demoscene.asm</a>
							<a class="dropdown-item loadButton" href="#">disco.asm</a>
							<a class="dropdown-item loadButton" href="#">fullscreenlogo.asm</a>
							<a class="dropdown-item loadButton" href="#">gameoflife.asm</a>
							<a class="dropdown-item loadButton" href="#">random.asm</a>
							<a class="dropdown-item loadButton" href="#">spacer.asm</a>
							<a class="dropdown-item loadButton" href="#">starfield2d.asm</a>
							<a class="dropdown-item loadButton" href="#">skier.asm</a>
							<a class="dropdown-item loadButton" href="#">sierpinsky.asm</a>
							<a class="dropdown-item loadButton" href="#">softsprites.asm</a>
							<a class="dropdown-item loadButton" href="#">snake.asm</a>
						</div>
					</div>
					<textarea class="code">
					</textarea>

					<canvas class="screen" width="192" height="192"></canvas>

					<div class="debugger">
						<input type="checkbox" class="debug" name="debug" />
						<label for="debug">Debugger</label>
						<div class="minidebugger"></div>
						<div class="btn-group btn-group-sm btn-block buttons">
							<input type="button" value="Step" class="btn btn-secondary stepButton" />
							<input type="button" value="Jump to..." class="btn btn-secondary gotoButton" />
						</div>
					</div>

					<div class="monitorControls">
						<label for="monitoring">Monitor</label>
						<input type="checkbox" class="monitoring" name="monitoring" />
						<label for="start">Start: $</label>
						<input type="text" value="0" class="start" name="start" />
						<label for="length">Length: $</label>
						<input type="text" value="ff" class="length" name="length" />
					</div>
					<div class="frequencyControls">
						<label for="frequency">Execution frequency: </label>
						<input type="range" min="1" max="512" value="256" class="frequency">
					</div>

					<div class="monitor">
						<pre><code></code></pre>
					</div>
					<div class="messages">
						<pre><code></code></pre>
					</div>
				</div>
			</div> <!-- column -->
			<div class="col">
<div id="user-guide" data-spy="scroll" data-target=".toc">
<div id="INTRO">
<h3>Introduction</h3>

<p>This site contains documentation for the various 
<a href="https://en.wikipedia.org/wiki/MOS_Technology_6502">MOS 6502</a> opcodes 
and concepts, an editor that lets you write your own programs and a simulator
that lets you run these. The <b>Load</b> menu will load example programs 
contributed by various authors.</p>

<h4>Credits:</h4>
<ul>
<li>Sindre Sørhus wrote the <a href="http://6502asm.com" target="_new">original 6502 simulator</a> in JavaScript.</li>
<li>Nick Morgan adapted the simulator for <a href="http://skilldrick.github.io/easy6502/" target="_new">Easy 6502</a>. It's a nice introduction, you might want to start there.</li>
<li>John Pickens, Bruce Clark and Ed Spittles wrote the <a href="http://www.6502.org/tutorials/6502opcodes.html" target="_new">NMOS 6502 Opcodes</a> documentation used in this site.</li> 
<li>Torkild Ulvøy Resheim adapted the simulator for the <a href="https://itema-as.github.io/6502js" target="_new">MOS 6502 Simulator</a> (this) site, updated and added documentation.</li>
</ul>

<p>This web site was put together as a part of a introductory tutorial on 6502
assembly for <a href="https://itema.no" target="_new">Itema AS</a>. The layout
have been designed to work fine on an iPad or iPad Pro. Feel free 
to fork the project on 
<a href="https://github.com/Itema-as/6502js" target="_new">GitHub</a>.</p>

<img src="Itema_logo.png" id="logo"/>

</div>

<!-- SECTION ============================================================== -->

<div id="NOTES">
<h3>Notes</h3>

<p>Memory location <code>$fe</code> contains a new random byte on every instruction.
Memory location <code>$ff</code> contains the ascii code of the last key pressed.</p>

<p>Memory locations <code>$200</code> to <code>$5ff</code> map to the screen 
pixels (1024 of them). The screen is 32 x 32 pixels in size. Different values 
wil draw different colour pixels. The colours are:</p>

<pre>
<span class="colorbox" style="background-color: #000000"></span>$0: Black         <span class="colorbox" style="background-color: #dd8855"></span>$8: Orange
<span class="colorbox" style="background-color: #ffffff"></span>$1: White         <span class="colorbox" style="background-color: #664400"></span>$9: Brown
<span class="colorbox" style="background-color: #880000"></span>$2: Red           <span class="colorbox" style="background-color: #ff7777"></span>$a: Light red
<span class="colorbox" style="background-color: #aaffee"></span>$3: Cyan          <span class="colorbox" style="background-color: #333333"></span>$b: Dark grey
<span class="colorbox" style="background-color: #cc44cc"></span>$4: Purple        <span class="colorbox" style="background-color: #777777"></span>$c: Grey
<span class="colorbox" style="background-color: #00cc55"></span>$5: Green         <span class="colorbox" style="background-color: #aaff66"></span>$d: Light green
<span class="colorbox" style="background-color: #0000aa"></span>$6: Blue          <span class="colorbox" style="background-color: #0088ff"></span>$e: Light blue
<span class="colorbox" style="background-color: #eeee77"></span>$7: Yellow        <span class="colorbox" style="background-color: #bbbbbb"></span>$f: Light grey
</pre>
</div>
<p>This documentation was copied from actual MOS 6502 documentation and 
currently contains some information that does not apply here. For instance 
everything related to interrupts, which are not supported by the simulator.
Also the various timing details are probably not accurate.</p>

<h4>The DCB compiler directive</h4>
<p>The <code>DCB</code> directive allocates one or more bytes of memory, and
defines the initial runtime contents of the memory. When combined with a label
one can reference this in an assember instruction. For example:</p>
<pre>
lda ypos,x
ypos:
 dcb $00,$02,$20,$02,$40,$02,$60,$02
 dcb $80,$02,$a0,$02,$c0,$02,$e0,$02
</pre>
<p>This will load the value of <code>ypos</code> on position <code>x</code> in
to the <code>A register</code>.</p>

<!-- SECTION ============================================================== -->

<h3 id="PC">Program Counter</h3>

<p>When the 6502 is ready for the next instruction it increments the program
counter before fetching the instruction. Once it has the op code, it increments
the program counter by the length of the operand, if any. This must be accounted
for when calculating branches or when pushing bytes to create a false return
address (i.e. jump table addresses are made up of addresses-1 when it is
intended to use an RTS rather than a JMP).</p>

<p>The program counter is loaded least signifigant byte first. Therefore the
most signifigant byte must be pushed first when creating a false return address.</p>

<p>When calculating branches a forward branch of 6 skips the following 6 bytes
so, effectively the program counter points to the address that is 8 bytes beyond
the address of the branch opcode; and a backward branch of $FA (256-6) goes to
an address 4 bytes before the branch instruction.</p>

<!-- SECTION ============================================================== -->

<h3 id="WRAP">Wrap-Around</h3>

<p>Use caution with indexed zero page operations as they are subject to
wrap-around. For example, if the X register holds $FF and you execute LDA $80,X
you will not access $017F as you might expect; instead you access $7F i.e.
$80-1. This characteristic can be used to advantage but make sure your code is
well commented.</p>

<p>It is possible, however, to access $017F when X = $FF by using the Absolute,X
addressing mode of LDA $80,X. That is, instead of:</p>

<pre>
  LDA $80,X
</pre>
<p><code>ZeroPage,X</code> - the resulting object code is <code>B5 80</code> 
which accesses $007F when X=$FF, use:</p>

<pre>
  LDA $0080,X
</pre>

<p><code>Absolute,X</code> - the resulting object code is: <code>BD 80 00</code>
which accesses $017F when X = $FF (a at cost of one additional byte and one
additional cycle). All of the ZeroPage,X and ZeroPage,Y instructions except
STX ZeroPage,Y and STY ZeroPage,X have a corresponding Absolute,X and
Absolute,Y instruction. Unfortunately, a lot of 6502 assemblers don't have an
easy way to force Absolute addressing, i.e. most will assemble a LDA $0080,X
as B5 80.  One way to overcome this is to insert the bytes using the .BYTE
pseudo-op (on some 6502 assemblers this pseudo-op is called DB or DFB,
consult the assembler documentation) as follows:</p>

<pre>
  .BYTE $BD,$80,$00
</pre>

<p>In cases where you are writing code that will be relocated you must consider
wrap-around when assigning dummy values for addresses that will be adjusted.
Both zero and the semi-standard $FFFF should be avoided for dummy labels. The
use of zero or zero page values will result in assembled code with zero page
opcodes when you wanted absolute codes. With $FFFF, the problem is in
addresses+1 as you wrap around to page 0.</p>

<!-- SECTION ============================================================== -->

<div id="ADC">
<h3>ADC (ADd with Carry)</h3>
<p>Affects Flags: N V Z C</p>
<pre>
MODE          SYNTAX        HEX
Immediate     ADC #$44      $69
Zero Page     ADC $44       $65
Zero Page,X   ADC $44,X     $75
Absolute      ADC $4400     $6D
Absolute,X    ADC $4400,X   $7D
Absolute,Y    ADC $4400,Y   $79
Indirect,X    ADC ($44,X)   $61
Indirect,Y    ADC ($44),Y   $71

+ add 1 cycle if page boundary crossed
</pre>

<p>ADC results are dependant on the setting of the <a href="#DFLAG">decimal flag</a>.
In decimal mode, addition is carried out on the assumption that the values 
involved are packed BCD (Binary Coded Decimal).</p>
<p>There is no way to add without carry.</p>
</div>
<!-- SECTION ============================================================== -->

<h3 id="AND">AND (bitwise AND with accumulator)</h3>

<p>Affects Flags: N Z</p>

<pre>
MODE          SYNTAX        HEX
Immediate     AND #$44      $29
Zero Page     AND $44       $25
Zero Page,X   AND $44,X     $35
Absolute      AND $4400     $2D
Absolute,X    AND $4400,X   $3D
Absolute,Y    AND $4400,Y   $39
Indirect,X    AND ($44,X)   $21
Indirect,Y    AND ($44),Y   $31

+ add 1 cycle if page boundary crossed
</pre>

<!-- SECTION ============================================================== -->

<h3 id="ASL">ASL (Arithmetic Shift Left)</h3>

<p>Affects Flags: N Z C</p> 

<pre>
MODE          SYNTAX        HEX
Accumulator   ASL A         $0A
Zero Page     ASL $44       $06
Zero Page,X   ASL $44,X     $16
Absolute      ASL $4400     $0E
Absolute,X    ASL $4400,X   $1E
</pre>
<p>
<img src="images/asl.svg"/>
</p>
<p>ASL shifts all bits left one position. 0 is shifted into bit 0 and the
original bit 7 is shifted into the Carry.</p>

<!-- SECTION ============================================================== -->

<div id="BCC"></div><div id="BCS"></div><div id="BEQ"></div><div id="BNE"></div>
<div id="BMI"></div><div id="BPL"></div><div id="BVC"></div><div id="BVS"></div>
<div id="BRA"></div>
<h3>Branch Instructions</h3>

<p>Affect Flags: none</p>

<p>All branches are relative mode and have a length of two bytes. Syntax is "Bxx
Displacement" or (better) "Bxx Label". See the notes on the <a
href="#PC">Program Counter</a> for more on displacements.</p>

<p>Branches are dependant on the status of the flag bits when the op code is
encountered. A branch not taken requires two machine cycles. Add one if the
branch is taken and add one more if the branch crosses a page boundary.</p>

<pre>
MNEMONIC                       HEX
BPL (Branch on PLus)           $10
BMI (Branch on MInus)          $30
BVC (Branch on oVerflow Clear) $50
BVS (Branch on oVerflow Set)   $70
BCC (Branch on Carry Clear)    $90
BCS (Branch on Carry Set)      $B0
BNE (Branch on Not Equal)      $D0
BEQ (Branch on EQual)          $F0
</pre>

<p>There is no BRA (BRanch Always) instruction but it can be easily emulated
by branching on the basis of a known condition. One of the best flags to use for
this purpose is the <a href="#VFLAG">oVerflow</a> which is unchanged
by all but addition and subtraction operations.</p>

<p>A page boundary crossing occurs when the branch destination is on a different
page than the instruction AFTER the branch instruction. For example:</p>

<pre>
  SEC
  BCS LABEL
  NOP
</pre>

<p>A page boundary crossing occurs (i.e. the BCS takes 4 cycles) when (the
address of) LABEL and the NOP are on different pages. This means that</p>

<pre>
        CLV
        BVC LABEL
  LABEL NOP
</pre>

<p>the BVC instruction will take 3 cycles no matter what address it is located
at.</p>

<!-- SECTION ============================================================== -->

<h3 id="BIT">BIT (test BITs)</h3>

<p>Affects Flags: N V Z</p> 

<pre>
MODE          SYNTAX        HEX
Zero Page     BIT $44       $24
Absolute      BIT $4400     $2C
</pre>

<p>BIT sets the Z flag as though the value in the address tested were ANDed
with the accumulator. The N and V flags are set to match bits 7 and 6
respectively in the value stored at the tested address.</p>

<p>BIT is often used to skip one or two following bytes as in:</p>

<pre>CLOSE1 LDX #$10   If entered here, we
       .BYTE $2C  effectively perform
CLOSE2 LDX #$20   a BIT test on $20A2,
       .BYTE $2C  another one on $30A2,
CLOSE3 LDX #$30   and end up with the X
CLOSEX LDA #12    register still at $10
       STA ICCOM,X upon arrival here.
</pre>

<p>Beware: a BIT instruction used in this way as a NOP does have effects: the flags
may be modified, and the read of the absolute address, if it happens to access an
I/O device, may cause an unwanted action.</p>

<!-- SECTION ============================================================== -->

<h3 id="BRK">BRK (BReaK) </h3>

<p>Affects Flags: B</p>

<pre>
MODE          SYNTAX        HEX
Implied       BRK           $00
</pre>

<p>BRK causes a non-maskable interrupt and increments the program counter by
one.  Therefore an <a href="#RTI">RTI</a> will go to the address of the BRK +2 
so that BRK may be used to replace a two-byte instruction for debugging and the
subsequent RTI will be correct.</p>

<!-- SECTION ============================================================== -->

<h3 id="CMP">CMP (CoMPare accumulator)</h3>

<p>Affects Flags: N Z C</p>

<pre>
MODE          SYNTAX        HEX
Immediate     CMP #$44      $C9
Zero Page     CMP $44       $C5
Zero Page,X   CMP $44,X     $D5
Absolute      CMP $4400     $CD
Absolute,X    CMP $4400,X   $DD
Absolute,Y    CMP $4400,Y   $D9
Indirect,X    CMP ($44,X)   $C1
Indirect,Y    CMP ($44),Y   $D1

+ add 1 cycle if page boundary crossed
</pre>

<p>Compare sets flags as if a subtraction had been carried out. If the value
in the accumulator is equal or greater than the compared value, the Carry will
be set. The equal (Z) and negative (N) flags will be set based on equality or
lack thereof and the sign (i.e. A&gt;=$80) of the accumulator.</p>

<!-- SECTION ============================================================== -->

<h3 id="CPX">CPX (ComPare X register)</h3>

<p>Affects Flags: N Z C</p>

<pre>
MODE          SYNTAX        HEX
Immediate     CPX #$44      $E0
Zero Page     CPX $44       $E4
Absolute      CPX $4400     $EC
</pre>

<p>Operation and flag results are identical to equivalent mode accumulator <a
href="#CMP">CMP</a> ops.</p>

<!-- SECTION ============================================================== -->

<h3 id="CPY">CPY (ComPare Y register)</h3>

<p>Affects Flags: N Z C</p>

<pre>
MODE          SYNTAX        HEX
Immediate     CPY #$44      $C0
Zero Page     CPY $44       $C4
Absolute      CPY $4400     $CC
</pre>

<p>Operation and flag results are identical to equivalent mode accumulator <a
href="#CMP">CMP</a> ops.</p>

<!-- SECTION ============================================================== -->

<h3 id="DEC">DEC (DECrement memory)</h3>

<p>Affects Flags: N Z</p>

<pre>
MODE          SYNTAX        HEX
Zero Page     DEC $44       $C6
Zero Page,X   DEC $44,X     $D6
Absolute      DEC $4400     $CE
Absolute,X    DEC $4400,X   $DE
</pre>

<!-- SECTION ============================================================== -->

<h3 id="EOR">EOR (bitwise Exclusive OR)</h3>

<p>Affects Flags: N Z</p>

<pre>
MODE          SYNTAX       HEX
Immediate     EOR #$44      $49
Zero Page     EOR $44       $45
Zero Page,X   EOR $44,X     $55
Absolute      EOR $4400     $4D
Absolute,X    EOR $4400,X   $5D
Absolute,Y    EOR $4400,Y   $59
Indirect,X    EOR ($44,X)   $41
Indirect,Y    EOR ($44),Y   $51

+ add 1 cycle if page boundary crossed
</pre>

<!-- SECTION ============================================================== -->

<a id="CLC"></a><a id="SEC"></a><a ID="CLD"></a><a id="SED"></a><a id="CLI"></a>
<a id="SEI"></a>

<h3>Flag (Processor Status) Instructions</h3>

<p>Affect Flags: as noted</p>

<p>These instructions are implied mode, have a length of one byte and require
two machine cycles.</p>

<pre>
MNEMONIC                       HEX
CLC (CLear Carry)              $18
SEC (SEt Carry)                $38
CLI (CLear Interrupt)          $58
SEI (SEt Interrupt)            $78
CLV (CLear oVerflow)           $B8
CLD (CLear Decimal)            $D8
SED (SEt Decimal)              $F8
</pre>

<p id="IFLAG">The Interrupt flag is used to prevent (SEI) or
enable (CLI) maskable interrupts (aka IRQ's). It does not signal the presence or
absence of an interrupt condition. The 6502 will set this flag automatically in
response to an interrupt and restore it to its prior status on completion of the
interrupt service routine. If you want your interrupt service routine to permit
other maskable interrupts, you must clear the I flag in your code.</p>

<p id="DFLAG">The Decimal flag controls how the 6502 adds and
subtracts. If set, arithmetic is carried out in packed binary coded decimal.
This flag is unchanged by interrupts and is unknown on power-up. The implication
is that a CLD should be included in boot or interrupt coding.</p>

<p id="VFLAG">The Overflow flag is generally misunderstood and
therefore under-utilised. After an ADC or SBC instruction, the overflow flag
will be set if the twos complement result is less than -128 or greater than
+127, and it will cleared otherwise. In twos complement, $80 through $FF
represents -128 through -1, and $00 through $7F represents 0 through +127.
Thus, after:</p>

<pre>
  CLC
  LDA #$7F ;   +127
  ADC #$01 ; +   +1
</pre>

<p>the overflow flag is 1 (+127 + +1 = +128), and after:</p>

<pre>
  CLC
  LDA #$81 ;   -127
  ADC #$FF ; +   -1
</pre>

<p>the overflow flag is 0 (-127 + -1 = -128). The overflow flag is not
affected by increments, decrements, shifts and logical operations i.e. only
ADC, BIT, CLV, PLP, RTI and SBC affect it. There is no op code to set the
overflow but a BIT test on an RTS instruction will do the trick.</p>

<!-- SECTION ============================================================== -->

<h3 id="INC">INC (INCrement memory)</h3>

<p>Affects Flags: N Z</p>

<pre>
MODE          SYNTAX        HEX
Zero Page     INC $44       $E6
Zero Page,X   INC $44,X     $F6
Absolute      INC $4400     $EE
Absolute,X    INC $4400,X   $FE
</pre>

<!-- SECTION ============================================================== -->

<h3 id="JMP">JMP (JuMP)</h3>

<p>Affects Flags: none</p>

<pre>
MODE          SYNTAX        HEX
Absolute      JMP $5597     $4C
Indirect      JMP ($5597)   $6C
</pre>

<p>JMP transfers program execution to the following address (absolute) or to
the location contained in the following address (indirect). Note that there is
no carry associated with the indirect jump so: <strong>AN INDIRECT JUMP MUST NEVER USE A
VECTOR BEGINNING ON THE LAST BYTE
OF A PAGE</strong></p>

<p>For example if address $3000 contains $40, $30FF contains $80, and $3100
contains $50, the result of JMP ($30FF) will be a transfer of control to $4080
rather than $5080 as you intended i.e. the 6502 took the low byte of the address
from $30FF and the high byte from $3000.</p>

<!-- SECTION ============================================================== -->

<h3 id="JSR">JSR (Jump to SubRoutine)</h3>

<p>Affects Flags: none</p>

<pre>
MODE          SYNTAX        HEX
Absolute      JSR $5597     $20
</pre>

<p>JSR pushes the address-1 of the next operation on to the stack before
transferring program control to the following address. Subroutines are normally
terminated by a <a href="#RTS">RTS</a> opcode.</p>

<!-- SECTION ============================================================== -->

<h3 id="LDA">LDA (LoaD Accumulator)</h3>

<p>Affects Flags: N Z</p>

<pre>
MODE          SYNTAX        HEX
Immediate     LDA #$44      $A9
Zero Page     LDA $44       $A5
Zero Page,X   LDA $44,X     $B5
Absolute      LDA $4400     $AD
Absolute,X    LDA $4400,X   $BD
Absolute,Y    LDA $4400,Y   $B9
Indirect,X    LDA ($44,X)   $A1
Indirect,Y    LDA ($44),Y   $B1

+ add 1 cycle if page boundary crossed
</pre>

<!-- SECTION ============================================================== -->

<h3 id="LDX">LDX (LoaD X register)</h3>

<p>Affects Flags: N Z</p>

<pre>
MODE          SYNTAX        HEX
Immediate     LDX #$44      $A2
Zero Page     LDX $44       $A6
Zero Page,Y   LDX $44,Y     $B6
Absolute      LDX $4400     $AE
Absolute,Y    LDX $4400,Y   $BE

+ add 1 cycle if page boundary crossed
</pre>

<!-- SECTION ============================================================== -->

<h3 id="LDY">LDY (LoaD Y register)</h3>

<p>Affects Flags: N Z</p>

<pre>
MODE          SYNTAX        HEX
Immediate     LDY #$44      $A0
Zero Page     LDY $44       $A4
Zero Page,X   LDY $44,X     $B4
Absolute      LDY $4400     $AC
Absolute,X    LDY $4400,X   $BC

+ add 1 cycle if page boundary crossed
</pre>

<!-- SECTION ============================================================== -->

<h3 id="LSR">LSR (Logical Shift Right)</h3>

<p>Affects Flags: N Z C</p>

<pre>
MODE          SYNTAX        HEX
Accumulator   LSR A         $4A
Zero Page     LSR $44       $46
Zero Page,X   LSR $44,X     $56
Absolute      LSR $4400     $4E
Absolute,X    LSR $4400,X   $5E
</pre>
<p>
<img src="images/lsr.svg"/>
</p>
<p>LSR shifts all bits right one position. 0 is shifted into bit 7 and the
original bit 0 is shifted into the Carry.</p>

<!-- SECTION ============================================================== -->

<h3 id="TIMES">Execution Times</h3>

<p>Op code execution times are measured in machine cycles; one machine cycle
equals one clock cycle. Many instructions require one extra cycle for
execution if a page boundary is crossed; these are indicated by a + following
the time values shown.</p>

<!-- SECTION ============================================================== -->

<h3 id="NOP">NOP (No OPeration)</h3>

<p>Affects Flags: none</p>

<pre>MODE           SYNTAX       HEX LEN TIM
Implied       NOP           $EA  1   2
</pre>

<p>NOP is used to reserve space for future modifications or effectively REM
out existing code.</p>

<!-- SECTION ============================================================== -->

<h3 id="ORA">ORA (bitwise OR with Accumulator)</h3>
<p>Affects Flags: N Z</p>

<pre>
MODE          SYNTAX        HEX
Immediate     ORA #$44      $09
Zero Page     ORA $44       $05
Zero Page,X   ORA $44,X     $15
Absolute      ORA $4400     $0D
Absolute,X    ORA $4400,X   $1D
Absolute,Y    ORA $4400,Y   $19
Indirect,X    ORA ($44,X)   $01
Indirect,Y    ORA ($44),Y   $11

+ add 1 cycle if page boundary crossed
</pre>

<!-- SECTION ============================================================== -->

<a id="TAX"></a><a id="TXA"></a><a id="TAY"></a><a id="TYA"></a><a id="INX"></a>
<a id="DEX"></a><a id="INY"></a><a id="DEY"></a>

<h3>Register Instructions </h3>

<p>Affect Flags: N Z</p>

<p>These instructions are implied mode, have a length of one byte and require
two machine cycles.</p>

<pre>
MNEMONIC                 HEX
TAX (Transfer A to X)    $AA
TXA (Transfer X to A)    $8A
DEX (DEcrement X)        $CA
INX (INcrement X)        $E8
TAY (Transfer A to Y)    $A8
TYA (Transfer Y to A)    $98
DEY (DEcrement Y)        $88
INY (INcrement Y)        $C8
</pre>

<!-- SECTION ============================================================== -->

<h3 id="ROL">ROL (ROtate Left)</h3>

<p>Affects Flags: N Z C</p>

<pre>
MODE          SYNTAX        HEX
Accumulator   ROL A         $2A
Zero Page     ROL $44       $26
Zero Page,X   ROL $44,X     $36
Absolute      ROL $4400     $2E
Absolute,X    ROL $4400,X   $3E
</pre>
<p>
<img src="images/rol.svg"/>
</p>
<p>ROL shifts all bits left one position. The Carry is shifted into bit 0 and
the original bit 7 is shifted into the Carry.</p>

<!-- SECTION ============================================================== -->

<h3 id="ROR">ROR (ROtate Right)</h3>

<p>Affects Flags: N Z C</p>

<pre>
MODE          SYNTAX        HEX
Accumulator   ROR A         $6A
Zero Page     ROR $44       $66
Zero Page,X   ROR $44,X     $76
Absolute      ROR $4400     $6E
Absolute,X    ROR $4400,X   $7E
</pre>
<p>
<img src="images/ror.svg"/>
</p>
<p>ROR shifts all bits right one position. The Carry is shifted into bit 7
and the original bit 0 is shifted into the Carry.</p>

<!-- SECTION ============================================================== -->

<h3 id="RTI">RTI (ReTurn from Interrupt)</h3>

<p>Affects Flags: all</p>

<pre>
MODE          SYNTAX        HEX
Implied       RTI           $40
</pre>

<p>RTI retrieves the Processor Status Word (flags) and the Program Counter
from the stack in that order (interrupts push the PC first and then the PSW).</p>
<p>Note that unlike RTS, the return address on the stack is the actual address
rather than the address-1.</p>

<!-- SECTION ============================================================== -->

<h3 id="RTS">RTS (ReTurn from Subroutine)</h3>

<p>Affects Flags: none</p>

<pre>
MODE          SYNTAX        HEX
Implied       RTS           $60
</pre>

<p>RTS pulls the top two bytes off the stack (low byte first) and transfers
program control to that address+1. It is used, as expected, to exit a subroutine
invoked via <a href="#JSR">JSR</a> which
pushed the address-1.</p>

<p>RTS is frequently used to implement a jump table where addresses-1 are pushed
onto the stack and accessed via RTS eg. to access the second of four routines:</p> 

<pre> LDX #1
 JSR EXEC
 JMP SOMEWHERE

LOBYTE
 .BYTE &lt;ROUTINE0-1,&lt;ROUTINE1-1
 .BYTE &lt;ROUTINE2-1,&lt;ROUTINE3-1

HIBYTE
 .BYTE &gt;ROUTINE0-1,&gt;ROUTINE1-1
 .BYTE &gt;ROUTINE2-1,&gt;ROUTINE3-1

EXEC
 LDA HIBYTE,X
 PHA
 LDA LOBYTE,X
 PHA
 RTS
</pre>

<!-- SECTION ============================================================== -->

<h3 id="SBC">SBC (SuBtract with Carry)</h3>

<p>Affects Flags: N V Z C</p>

<pre>
MODE          SYNTAX        HEX
Immediate     SBC #$44      $E9
Zero Page     SBC $44       $E5
Zero Page,X   SBC $44,X     $F5
Absolute      SBC $4400     $ED
Absolute,X    SBC $4400,X   $FD
Absolute,Y    SBC $4400,Y   $F9
Indirect,X    SBC ($44,X)   $E1
Indirect,Y    SBC ($44),Y   $F1

+ add 1 cycle if page boundary crossed
</pre>

<p>SBC results are dependant on the setting of the decimal flag. In decimal
mode, subtraction is carried out on the assumption that the values involved are
packed BCD (Binary Coded Decimal).</p>

<p>There is no way to subtract without the carry which works as an inverse
borrow. i.e, to subtract you set the carry before the operation. If the carry is
cleared by the operation, it indicates a borrow occurred.</p>

<!-- SECTION ============================================================== -->

<h3 id="STA">STA (STore Accumulator)</h3>

<p>Affects Flags: none</p>

<pre>
MODE          SYNTAX        HEX
Zero Page     STA $44       $85
Zero Page,X   STA $44,X     $95
Absolute      STA $4400     $8D
Absolute,X    STA $4400,X   $9D
Absolute,Y    STA $4400,Y   $99
Indirect,X    STA ($44,X)   $81
Indirect,Y    STA ($44),Y   $91
</pre>

<!-- SECTION ============================================================== -->

<a id="TXS"></a><a id="TSX"></a><a id="PHA"></a><a id="PLA"></a><a id="PHP"></a>
<a id="PLP"></a><a id="STACK"></a>

<h3>Stack Instructions</h3>

<p>These instructions are implied mode, have a length of one byte and require
machine cycles as indicated. The "PuLl" operations are known as "POP" on most
other microprocessors. With the 6502, the stack is always on page one
($100-$1FF) and works top down.</p>

<pre>
MNEMONIC                        HEX
TXS (Transfer X to Stack ptr)   $9A
TSX (Transfer Stack ptr to X)   $BA
PHA (PusH Accumulator)          $48
PLA (PuLl Accumulator)          $68
PHP (PusH Processor status)     $08
PLP (PuLl Processor status)     $28
</pre>

<!-- SECTION ============================================================== -->

<h3 id="STX">STX (STore X register)</h3>

<p>Affects Flags: none</p>

<pre>
MODE          SYNTAX        HEX
Zero Page     STX $44       $86
Zero Page,Y   STX $44,Y     $96
Absolute      STX $4400     $8E
</pre>

<!-- SECTION ============================================================== -->

<div id="STY">
<h3>STY (STore Y register)</h3>

<p>Affects Flags: none</p>

<pre>
MODE          SYNTAX        HEX
Zero Page     STY $44       $84
Zero Page,X   STY $44,X     $94
Absolute      STY $4400     $8C
</pre>
</div>

</div> <!--details -->
			</div> <!-- column -->
		</div> <!--row -->
		
	</div><!-- container -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
		integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
		crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
		integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
		crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
		integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
		crossorigin="anonymous"></script>
	<script src="assembler.js"></script>
	<script src="es5-shim.js"></script>
</body>
</html>
